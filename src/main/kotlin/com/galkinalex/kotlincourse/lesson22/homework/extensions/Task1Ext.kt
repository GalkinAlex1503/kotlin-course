package com.galkinalex.kotlincourse.lesson22.homework.extensions

//Тренируемся составлять сигнатуру функции расширяющей класс.
// Можешь проявить свою творческую жилку и в коде функции что-нибудь сделать с входящими данными,
// чтобы вернуть итоговый результат или распечатать его, если нет возвращаемого типа.
//
// a. Определите функцию-расширение для массива чисел, которая не принимает аргументов и возвращает пару из чисел.
//
// b. Напишите функцию-расширение для класса символа, допускающего null,
// которая принимает три аргумента: два типа число и один булево, и ничего не возвращает.
//
// c. Создайте функцию-расширение для класса изменяемого списка элементов с дженериком,
// которая принимает два аргумента: один типа дженерик, допускающий null, и другой типа число,
// и возвращает значение типа дженерик, допускающий null.
//
// d. Реализуйте функцию-расширение для класса словаря допускающего null с ключами дженериком
// и значениями типа список из такого же дженерика, которая принимает один аргумент типа число
// и возвращает словарь допускающий null с ключами типа строка и значениями типа дженерика допускающего null.
//
// e. Определите функцию-расширение для класса длинного числа, допускающее null,
// которая не принимает аргументов и возвращает строку.

fun Array<Int>.funA(): Pair<Int, Int> {
    return 0 to 0
}

fun Char?.funB(arg1: Int, arg2: Int, arg3: Boolean) {
    println("funB arg1: $arg1  arg2: $arg2 arg3: $arg3")
}

fun <T> MutableList<T>.funC(arg1: T?, arg2: Int): T? {
    if (arg2 >= this.size) return null
    return  if (this.get(arg2) === arg1) arg1
            else null

}

fun <T> Map<T, List<T>>?.funD(arg1: Int): Map<String, T?> {
    val vol: T? = null
    return mapOf("sdfs" to vol)
}

fun Long?.funE(): String {
    return this?.toString() ?: ""
}